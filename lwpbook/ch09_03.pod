=pod

^ Perl and LWP ^

=head1 9.3. Processing

Once you have parsed some HTML, you need to process it. Exactly what
you do will depend on the nature of your problem. Two common models are
extracting information and producing a transformed version of the HTML
(for example, to remove banner advertisements).

Whether extracting or transforming, you'll probably want to find the
bits of the document you're interested in. They might be all headings,
all bold italic regions, or all paragraphs with C<class="blinking">.
HTML::Element provides several functions for searching the tree.

=head2 9.3.1. Methods for Searching the Tree

In scalar context, these methods return the first node that satisfies
the criteria. In list context, all such nodes are returned. The methods
can be called on the root of the tree or any node in it.

=over

=item C<$node-E<gt>find_by_tag_name(>C<I<tag>> C<[, ...])>

Return node(s) for tags of the names listed. For example, to find all
C<h1> and C<h2> nodes:

 @headings = $root->find_by_tag_name('h1', 'h2');

=item C<$node-E<gt>find_by_attribute(>C<I<attribute>>, C<I<value>>C<)>

Returns the node(s) with the given attribute set to the given value.
For example, to find all nodes with C<class="blinking">:

 @blinkers = $root->find_by_attribute("class",
 "blinking");

=item C<$node-E<gt>look_down(...)>

=item C<$node-E<gt>look_up(...)>

These two methods search C<$node> and its children (and children's
children, and so on) in the case of C<look_down>, or its parent (and
the parent's parent, and so on) in the case of C<look_up>, looking for
nodes that match whatever criteria you specify. The parameters are
either C<attribute> C<=E<gt>> C<value> pairs (where the special
attribute C<_tag> represents the tag name), or a subroutine that is
passed a current node and returns true to indicate that this node is of
interest.

For example, to find all C<h2> nodes in the tree with
C<class="blinking">:

 @blinkers = $root->look_down(_tag => 'h2', class => 'blinking');

We'll discuss C<look_down> in greater detail later.

=back

=head2 9.3.2. Attributes of a Node

Four methods give access to the basic information in a node:

=over

=item C<$node-E<gt>tag( )>

The tag name string of this element. Example values: C<html>, C<img>,
C<blockquote>. Note that this is always lowercase.

=item C<$node-E<gt>parent( )>

This returns the node object that is the parent of this node. If
C<$node> is the root of the tree, C<$node-E<gt>parent( )> will return
C<undef>.

=item C<$node-E<gt>content_list( )>

This returns the (potentially empty) list of nodes that are this node's
children.

=item C<$node-E<gt>attr(>C<I<attributename>>C<)>

This returns the value of the HTML I<C<attributename>> attribute for
this element. If there is no such attribute for this element, this
returns C<undef>. For example: if C<$node> is parsed from C<E<lt>img>
C<src="x1.jpg"> C<alt="Looky!"E<gt>>, then C<$node-E<gt>attr("src")>
will return the string C<x1.jpg>.

=back

Four more methods convert a tree or part of a tree into another format,
such as HTML or text.

=over

=item C<$node-E<gt>as_HTML([> C<I<entities>> C<[>, C<I<indent_char>>
C<[>, C<I<optional_end_tags>> C<]]]);>

Returns a string consisting of the node and its children as HTML. The
C<I<C<entities>>> parameter is a string containing characters that
should be entity escaped (if empty, all potentially unsafe characters
are encoded as entities; if you pass just C<E<lt>E<gt>&>, just those
characters will get encodedE<mdash>a bare minimum for valid HTML). The
C<I<C<indent_char>>> parameter is a string used for indenting the HTML.
The C<I<C<optional_end_tags>>> parameter is a reference to a hash that
has a true value for every key that is the name of a tag whose closing
tag is optional. The most common value for this parameter is C<{}> to
force all tags to be closed:

 $html = $node->as_HTML("", "", {});

For example, this will emit C<E<lt>/liE<gt>> tags for any C<li> nodes
under C<$node>, even though C<E<lt>/liE<gt>> tags are technically
optional, according to the HTML specification.

Using C<$node-E<gt>as_HTML( )> with no parameters should be fine for
most purposes.

=item C<$node-E<gt>as_text( )>

Returns a string consisting of all the text nodes from this element and
its children.

=item C<$node-E<gt>starttag([>C<I<entities>>C<])>

Returns the HTML for the start-tag for this node. The C<I<C<entities>>>
parameter is a string of characters to entity escape, as in the
C<as_HTML( )> method; you can omit this. For example, if this node came
from parsing C<E<lt>TD> C<class=loudE<gt>HooboyE<lt>/TDE<gt>>, then
C<$node-E<gt>starttag( )> returns C<E<lt>td> C<class="loud"E<gt>>. Note
that the original source text is not reproduced exactly, because
insignificant differences, such as the capitalization of the tag name
or attribute names, will have been discarded during parsing.

=item C<$node-E<gt>endtag( )>

Returns the HTML for the end-tag for this node. For example, if this
node came from parsing C<E<lt>TD>
C<class=loudE<gt>HooboyE<lt>/TDE<gt>>, then C<$node-E<gt>endtag( )>
returns C<E<lt>/tdE<gt>>.

=back

These methods are useful once you've found the desired content. Example
9-4 prints all the bold italic text in a document.

=head2 Example 9-4. Bold-italic headline printer

 #!/usr/bin/perl -w
 
 use HTML::TreeBuilder;
 use strict;
 
 my $root = HTML::TreeBuilder->new_from_content(<<"EOHTML");
 <b><i>Shatner wins Award!</i></b>
 Today in <b>Hollywood</b> ...
 <b><i>End of World Predicted!</i></b>
 Today in <b>Washington</b> ...
 EOHTML
 $root->eof( );
 
 # print contents of <b><i>...</i></b>
 my @bolds = $root->find_by_tag_name('b');
 foreach my $node (@bolds) {
   my @kids = $node->content_list( );
   if (@kids and ref $kids[0] and $kids[0]->tag( ) eq 'i') {
     print $kids[0]->as_text( ), "\n";
   }
 }

Example 9-4 is fairly straightforward. Having parsed the string into a
new tree, we get a list of all the bold nodes. Some of these will be
the headlines we want, while others will simply be bolded text. In this
case, we can identify headlines by checking that the node that it
contains represents C<E<lt>iE<gt>...E<lt>/iE<gt>>. If it is an italic
node, we print its text content.

The only complicated part of Example 9-4 is the test to see whether
it's an interesting node. This test has three parts:

=over

=item C<@kids>

True if there are children of this node. An empty
C<E<lt>bE<gt>E<lt>/bE<gt>> would fail this test.

=item C<ref $kids[0]>

True if the first child of this node is an element. This is false in
cases such as C<E<lt>bE<gt>WashingtonE<lt>/bE<gt>>, where the first
(and here, only) child is text. If we fail to check this, the next
expression, C<$kids[0]-E<gt>tag( )>, would produce an error when
C<$kids[0]> isn't an object value.

=item C<$kids[0]-E<gt>tag( ) eq 'i'>

True if the first child of this node is an C<i> element. This would
weed out anything like C<E<lt>bE<gt>E<lt>img>
C<src="shatner.jpg"E<gt>E<lt>/bE<gt>>, where C<$kids[0]-E<gt>tag( )>
would return C<img>, or C<E<lt>bE<gt>E<lt>strongE<gt>Yes,>
C<Shatner!E<lt>/strongE<gt>E<lt>/bE<gt>>, where C<$kids[0]-E<gt>tag( )>
would return C<strong>.

=back

=head2 9.3.3. Traversing

For many tasks, you can use the built-in search functions. Sometimes,
though, you'd like to visit every node of the tree. You have two
choices: you can use the existing C<traverse( )> function or write your
own using either recursion or your own stack.

The act of visiting every node in a tree is called a I<traversal>.
Traversals can either be I<preorder> (where you process the current
node before processing its children) or I<postorder> (where you process
the current node after processing its children). The C<traverse( )>
method lets you do both:

 $node->traverse(callbacks [, ignore_text]);

The C<traverse( )> method calls a callback before processing the
children and again afterward. If the C<I<C<callbacks>>> parameter is a
single function reference, the same function is called before and after
processing the children. If the C<I<C<callbacks>>> parameter is an
array reference, the first element is a reference to a function called
before the children are processed, and the second element is similarly
called after the children are processed, unless this node is a text
segment or an element that is prototypically empty, such as C<br> or
C<hr>. (This last quirk of the C<traverse( )> method is one of the
reasons that I discourage its use.)

Callbacks get called with three values:

 sub callback 
   my ($node, $startflag, $depth,
       $parent, $my_index) = @_;
   # ...
 }

The current node is the first parameter. The next is a Boolean value
indicating whether we're being called before (true) or after (false)
the children, and the third is a number indicating how deep into the
traversal we are. The fourth and fifth parameters are supplied only for
text elements: the parent node object and the index of the current node
in its parent's list of children.

A callback can return any of the following values:

=over

=item C<HTML::Element::OK> (or any true value)

Continue traversing.

=item C<HTML::Element::PRUNE> (or any false value)

Do not go into the children. The postorder callback is not called.
(Ignored if returned by a postorder callback.)

=item C<HTML::Element::ABORT>

Abort the traversal immediately.

=item C<HTML::Element::PRUNE_UP>

Do not go into this node's children or into its parent node.

=item C<HTML::Element::PRUNE_SOFTLY>

Do not go into the children, but do call this node's postorder
callback.

=back

For example, to extract text from a node but not go into C<table>
elements:

 my $text;
 sub text_no_tables {
   return if ref $_[0] && $_[0]->tag eq 'table';
   $text .= $_[0] unless ref $_[0];  # only append text nodex
   return 1;                         # all is copacetic
 }
 
 $root->traverse([\&text_no_tables]);

This prevents descent into the contents of tables, while accumulating
the text nodes in C<$text>.

It can be hard to think in terms of callbacks, though, and the
multiplicity of return values and calling parameters you get with
C<traverse( )> makes for confusing code, as you will likely note when
you come across its use in existing programs that use
HTML::TreeBuilder.

Instead, it's usually easier and clearer to simply write your own
recursive subroutine, like this one:

 my $text = '';
 sub scan_for_non_table_text {
   my $element = $_[0];
   return if $element->tag eq 'table';   # prune!
   foreach my $child ($element->content_list) {
     if (ref $child) {  # it's an element
       scan_for_non_table_text($child);  # recurse!
     } else {           # it's a text node!
       $text .= $child;
     }
   }
   return;
 }
 scan_for_non_table_text($root);

Alternatively, implement it using a stack, doing the same work:

 my $text = '';
 my @stack = ($root);  # where to start
  
 while (@stack) {
   my $node = shift @stack;
   next if ref $node and $node->tag eq 'table';  # skip tables
   if (ref $node) {
     unshift @stack, $node->content_list;        # add children
   } else {
     $text .= $node;                             # add text
   }
 }

The C<while( )> loop version can be faster than the recursive version,
but at the cost of being much less clear to people who are unfamiliar
with this technique. If speed is a concern, you should always benchmark
the two versions to make sure you really need the speedup and that the
C<while( )> loop version actually delivers. The speed difference is
sometimes insignificant. The manual page C<perldoc>
C<HTML::Element::traverse> discusses writing more complex traverser
routines, in the rare cases where you might find this necessary.

=cut

#Pod::HTML2Pod conversion notes:
#From file ch09_03.htm
# 17310 bytes of input
#Sun Nov 11 18:10:08 2012 root
# No a_name switch not specified, so will not try to render <a name='...'>
# Will try to render <a href='...'>
# Untranslatable link: "./index.html"
# Untranslatable link: "ch09_03.htm#perllwp-CHP-9-EX-4"
# Untranslatable link: "ch09_03.htm#perllwp-CHP-9-EX-4"
# Untranslatable link: "ch09_03.htm#perllwp-CHP-9-EX-4"
